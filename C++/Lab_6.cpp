#include <iostream> // Подключение библиотеки для ввода-вывода
using namespace std; // Использование пространства имен std

struct Data // Определение структуры Data
{
	char Name[100]; // Поле для хранения имени
	char Job[50]; // Поле для хранения должности
	char BirthDay[3]; // Поле для хранения дня рождения
	char BirthMonth[3]; // Поле для хранения месяца рождения
	int BirthYear; // Поле для хранения года рождения
	double Money; // Поле для хранения заработной платы
};
void print_data(const Data data[]) // Функция для вывода данных о сотрудниках
{
	cout << "Ведомость начисленной заработной платы:\n\n"; // Вывод заголовка
	for (int i = 0; i < 5; ++i) // Цикл для прохода по всем сотрудникам
	{
		cout << "Ф.И.О.: " << data[i].Name << "\n"; // Вывод имени сотрудника
		cout << "Должность: " << data[i].Job << "\n"; // Вывод должности сотрудника
		cout << "Дата рождения: " << data[i].BirthDay << "." << data[i].BirthMonth << "." << data[i].BirthYear << "\n"; // Вывод даты рождения сотрудника
		cout << "Заработная плата: " << data[i].Money << "$\n"; // Вывод заработной платы сотрудника
		cout << "------------------------\n"; // Разделитель между сотрудниками
	}
}
void min_money(const Data data[]) // Функция для нахождения сотрудника с минимальной зарплатой
{
	Data min_money = data[0]; // Инициализация переменной для хранения данных сотрудника с минимальной зарплатой
	for (int i = 1; i < 5; ++i) // Цикл для прохода по всем сотрудникам
	{
		if (data[i].Money < min_money.Money) // Проверка, если текущая зарплата меньше минимальной
		{
			min_money = data[i]; // Обновление данных сотрудника с минимальной зарплатой
		}
	}
	cout << "\nСотрудник с самой маленькой зарплатой:\n"; // Вывод заголовка
	cout << "Дата рождения: " << min_money.BirthDay << "." << min_money.BirthMonth << "." << min_money.BirthYear << "\n"; // Вывод даты рождения сотрудника с минимальной зарплатой
}
void №1() // Функция для выполнения задачи №1
{
	struct Data data[] = // Инициализация массива структур Data
	{
		{"Панченко Ярослав Дмитриевич", "Разнорабочий", "21", "12", 2006, 10}, // Данные первого сотрудника
		{"Стрекалов Андрей Александрович", "WEB-разработчик", "09", "07", 2006, 100000}, // Данные второго сотрудника
		{"Попович Дмитрий Викторович", "Старший охранник", "07", "10", 2006, 50000}, // Данные третьего сотрудника
		{"Левченко Артём Максимович", "Техник-осеменатор", "23", "11", 2006, 1}, // Данные четвертого сотрудника
		{"Козлов Евгений Александрович", "Ведущий программист", "13", "10", 2006, 500000} // Данные пятого сотрудника
	};
	print_data(data); // Вызов функции для вывода данных о сотрудниках
	min_money(data); // Вызов функции для нахождения сотрудника с минимальной зарплатой
}

struct Domino // Определение структуры Domino
{
	int left;  // Левая часть домино
	int right; // Правая часть домино
};
void fill_dominoes(Domino dominoes[]) // Функция для заполнения массива домино значениями, введенными пользователем
{
	for (int i = 0; i < 28; ++i) // Цикл для заполнения 28 домино
	{
		cout << "Введите левую и правую части для кости " << i + 1 << ":\n"; // Запрос у пользователя ввода левой и правой частей для текущего домино
		cin >> dominoes[i].left >> dominoes[i].right; // Чтение введенных значений и сохранение их в соответствующие поля структуры
	}
}
bool check_dominoes(Domino dominoes[]) // Функция для проверки правильности выставления домино
{
	for (int i = 0; i < 27; ++i) // Цикл для проверки всех домино, кроме последнего
	{
		if (dominoes[i].right != dominoes[i + 1].left)
		{
			return false; // Если правая часть текущего домино не равна левой части следующего домино, возвращаем false
		}
	}
	return true; // Если все домино выставлены правильно, возвращаем true
}
void №2() // Функция для выполнения задачи №2
{
	Domino dominoes[28]; // Создание массива из 28 домино
	fill_dominoes(dominoes); // Заполнение массива домино значениями, введенными пользователем
	if (check_dominoes(dominoes)) // Проверка правильности выставления домино
	{
		cout << "\nКости выставлены правильно\n"; // Если домино выставлены правильно, выводим соответствующее сообщение
	}
	else
	{
		cout << "\nКости выставлены неправильно\n"; // Если домино выставлены неправильно, выводим соответствующее сообщение
	}
}

struct Coordinates // Определение структуры Coordinates
{
	double x; // Координата X
	double y; // Координата Y
};
struct Circle // Определение структуры Circle
{
	double radius; // Радиус окружности
	Coordinates center; // Центр окружности (координаты X и Y)
};
void №3() // Функция для выполнения задачи №3
{
	Circle circles[10]; // Массив для хранения 10 окружностей
	Circle filtered_circles[10]; // Массив для хранения отфильтрованных окружностей
	int filtered_count = 0; // Счетчик для отфильтрованных окружностей
	for (int i = 0; i < 10; ++i) // Цикл для ввода данных 10 окружностей
	{
		cout << "Введите радиус окружности " << i + 1 << ": "; // Запрос ввода радиуса
		cin >> circles[i].radius; // Ввод радиуса
		cout << "Введите координату X центра окружности " << i + 1 << ": "; // Запрос ввода координаты X центра
		cin >> circles[i].center.x; // Ввод координаты X центра
		cout << "Введите координату Y центра окружности " << i + 1 << ": "; // Запрос ввода координаты Y центра
		cin >> circles[i].center.y; // Ввод координаты Y центра
		cout << endl; // Переход на новую строку
	}
	for (int i = 0; i < 10; ++i) // Цикл для фильтрации окружностей с радиусом больше 1
	{
		if (circles[i].radius > 1) // Проверка, больше ли радиус 1
		{
			filtered_circles[filtered_count] = circles[i]; // Добавление окружности в массив отфильтрованных
			filtered_count++; // Увеличение счетчика отфильтрованных окружностей
		}
	}
	cout << "Окружности с радиусом больше 1:\n" << endl; // Вывод заголовка для отфильтрованных окружностей
	for (int i = 0; i < filtered_count; ++i) // Цикл для вывода отфильтрованных окружностей
	{
		cout << "Окружность " << i + 1 << ": " << endl; // Вывод номера окружности
		cout << "Радиус: " << filtered_circles[i].radius << endl; // Вывод радиуса окружности
		cout << "Центр (X, Y): (" << filtered_circles[i].center.x << ", " << filtered_circles[i].center.y << ")\n\n"; // Вывод координат центра окружности
	}
}

struct Book // Определение структуры Book
{
	char Author[100]; // Автор книги
	char Title[100];  // Название книги
	char Publisher[100]; // Издательство
	int Year; // Год издания
	double Price; // Цена книги
};
bool check_k(const char Publisher[100]) // Функция для проверки наличия буквы 'к' в названии издательства
{
	for (int i = 0; Publisher[i] != '\0'; ++i) // Перебор всех символов в строке Publisher
	{
		if (Publisher[i] == 'к')
		{
			return true; // Если найдена буква 'к', возвращаем true
		}
	}
	return false; // Если буква 'к' не найдена, возвращаем false
}
int сomparison_strings(const char str1[100], const char str2[100]) // Функция для сравнения двух строк
{
	int i = 0; // Индекс для перебора символов
	while (str1[i] != '\0' && str2[i] != '\0') // Перебор символов до конца одной из строк
	{
		if (str1[i] != str2[i])
		{
			return str1[i] - str2[i]; // Если символы не равны, возвращаем разницу
		}
		i++; // Переход к следующему символу
	}
	return str1[i] - str2[i]; // Возвращаем разницу последних символов
}
bool сomparison_title(Book a, Book b) // Функция для сравнения названий книг
{
	return сomparison_strings(a.Title, b.Title) < 0; // Возвращаем результат сравнения названий книг
}
void sort_books(Book books[10], int count) // Функция для сортировки массива книг по названию
{
	for (int i = 0; i < count - 1; ++i) // Внешний цикл для перебора всех книг
	{
		for (int j = 0; j < count - i - 1; ++j) // Внутренний цикл для сравнения и обмена книг
		{
			if (сomparison_title(books[j + 1], books[j])) // Если текущая книга должна быть после следующей, меняем их местами
			{
				Book temp = books[j]; // Временная переменная для хранения текущего элемента
				books[j] = books[j + 1]; // Меняем текущий элемент на следующий
				books[j + 1] = temp; // Меняем следующий элемент на временный
			}
		}
	}
}
void №4() // Функция для выполнения задачи №4
{
	Book books[10] = // Инициализация массива книг
	{
		{"Джоан Роулинг", "Гарри Поттер и философский камень", "Росмэн", 2002, 50},
		{"Лев Толстой", "Война и мир", "АСТ", 1867, 70},
		{"Джордж Оруэлл", "1984", "Эксмо", 2018, 45},
		{"Фёдор Достоевский", "Преступление и наказание", "Азбука", 1866, 60},
		{"Харпер Ли", "Убить пересмешника", "АСТ", 2017, 35},
		{"Эрнест Хемингуэй", "Старик и море", "Эксмо", 2016, 30},
		{"Маргарет Митчелл", "Унесённые ветром", "Азбука", 2012, 80},
		{"Джон Рональд Руэл Толкин", "Властелин колец", "АСТ", 2014, 120},
		{"Антуан де Сент-Экзюпери", "Маленький принц", "Росмэн", 2013, 25},
		{"Агата Кристи", "Убийство в Восточном экспрессе", "Эксмо", 2019, 40}
	};
	Book filtered_books[10]; // Массив для хранения отфильтрованных книг
	int count = 0; // Счетчик отфильтрованных книг
	for (int i = 0; i < 10; ++i) // Перебор всех книг для фильтрации
	{
		if (check_k(books[i].Publisher))
		{
			filtered_books[count++] = books[i]; // Если в названии издательства есть буква 'к', добавляем книгу в отфильтрованный массив
		}
	}
	sort_books(filtered_books, count); // Сортировка отфильтрованных книг по названию
	cout << "Отсортированный массив книг с буквой 'к' в названии издательства:\n\n"; // Вывод заголовка для отфильтрованных книг
	for (int i = 0; i < count; ++i) { // Цикл для вывода информации об отфильтрованных книгах
		cout << "Книга " << i + 1 << ": "; // Вывод номера книги
		cout << "Автор: " << filtered_books[i].Author << ", Название: " << filtered_books[i].Title; // Вывод автора и названия текущей книги
		cout << ", Издательство: " << filtered_books[i].Publisher << ", Год: " << filtered_books[i].Year; // Вывод издательства и года издания текущей книги
		cout << ", Стоимость: " << filtered_books[i].Price << "$\n"; // Вывод стоимости текущей книги
	}
}

struct Coordinates // Определение структуры Coordinates
{
	double x; // Координата X
	double y; // Координата Y
};
struct Circle // Определение структуры Circle
{
	double radius; // Радиус окружности
	Coordinates center; // Центр окружности (координаты X и Y)
};
void sort_сircles(Circle circles[], int size) // Функция для сортировки массива окружностей по возрастанию радиуса
{
	for (int i = 0; i < size - 1; ++i) // Внешний цикл для прохода по всем элементам массива
	{
		for (int j = 0; j < size - i - 1; ++j) // Внутренний цикл для сравнения элементов и их сортировки
		{
			if (circles[j].radius > circles[j + 1].radius) // Если текущий радиус больше следующего, меняем их местами
			{
				Circle temp = circles[j]; // Временная переменная для хранения текущего элемента
				circles[j] = circles[j + 1]; // Меняем текущий элемент на следующий
				circles[j + 1] = temp; // Меняем следующий элемент на временный
			}
		}
	}
}
void №5() // Функция для выполнения задачи №5
{
	setlocale(LC_ALL, "RUS");
	Circle circles[10]; // Массив для хранения 10 окружностей
	for (int i = 0; i < 10; ++i) // Цикл для ввода данных о каждой окружности
	{
		cout << "Введите информацию об окружности " << i + 1 << ":\n"; // Вывод номера текущей окружности
		cout << "Введите радиус окружности: "; // Запрос на ввод радиуса
		cin >> circles[i].radius; // Ввод радиуса
		cout << "Введите координату X центра окружности: "; // Запрос на ввод координаты X центра
		cin >> circles[i].center.x; // Ввод координаты X центра
		cout << "Введите координату Y центра окружности: "; // Запрос на ввод координаты Y центра
		cin >> circles[i].center.y; // Ввод координаты Y центра
		cout << endl; // Переход на новую строку
	}
	double sumRadius = 0.0; // Переменная для хранения суммы радиусов
	for (int i = 0; i < 10; ++i) // Цикл для вычисления суммы радиусов всех окружностей
	{
		sumRadius += circles[i].radius; // Добавление радиуса текущей окружности к сумме
	}
	cout << "Сумма радиусов всех окружностей: " << sumRadius << "\n"; // Вывод суммы радиусов
	sort_сircles(circles, 10); // Сортировка окружностей по возрастанию радиуса
	cout << "\nОтсортированные окружности по возрастанию радиуса:\n\n"; // Вывод заголовка для отсортированных окружностей
	for (int i = 0; i < 10; ++i) // Цикл для вывода информации об отсортированных окружностях
	{
		cout << "Окружность " << i + 1 << ": "; // Вывод номера окружности
		cout << "Радиус: " << circles[i].radius; // Вывод радиуса текущей окружности
		cout << ", Центр (X: " << circles[i].center.x << ", Y: " << circles[i].center.y << ")\n"; // Вывод координат центра текущей окружности
	}
}

int main() // Главная функция программы
{
	setlocale(LC_ALL, "RUS"); // Установка локали для корректного отображения русских символов
	№4(); // Вызов функции для выполнения задачи №4
	return 0; // Возврат 0, указывающий на успешное завершение программы
}